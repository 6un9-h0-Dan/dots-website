## The Design Problem

In a centralized world, search and discovery within a service doesn't involve
too many difficult decisions on the part of the user. When typing into a search
box, the user trusts that the service is giving them the results they've asked
for. This brings rise to  ranking algorithms, filter bubbles, censorship, and
other considerations where a user has little-to-no choice on how this search
and discovery is executed on their behalf. 

However, in a decentralized world, discovering and searching for new peers and
topics can be also difficult to discern. What data am I searching? Am
I searching and discovering content across the entire network, or just a subset
of the network? In a peer-to-peer application, you can only search for what you
have downloaded, or what your known peers have downloaded. If the network is
very large, it can be very slow and expensive (in terms of hard drives, cpu
power, time) to search through everything. This 'distributed search' is an open
research area that begins to break down for very large datasets.

These considerations can be governed by the protocol or client. For example,
the client can be 'fat' (e.g., download everything by default and search it
all); 'thin' (e.g., download very little and call out to another server); or
'gossipy' (e.g.,  search what my direct peers or peers of peers have
downloaded). This can cause confusion for users about what they are
downloading, what they (don't) see in the application, and how much of their
computer resources the app is allowed to use.

## The Design Solution

### Examples

## Why Choose ... ?

## Best Practice: How to Implement ...

## Potential Problems with ...

## The Take Away

## References & Where to Learn More
